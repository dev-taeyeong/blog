---
layout: post
title: '[TypeScript] 사용하기'
categories: TypeScript
author: taeyeong
date: 2022-02-09T19:37:28+0900
---
* content
{:toc}


---

앞에서 배운것처럼 모든 변수에 타입을 지정할 필요는 없다. 변수 생성시 타입스크립트가 자동으로 타입을 부여해준다.

```ts
let myName = 'taeyeong';
let age = 28;
```

이렇게 하면 myName 변수에는 string, age 변수에는 number 타입이 부여된다.

array, object를 만들 때도 자동으로 된다.

```ts
let myName;

myName = 'taeyeong';
```

변수만 만들고 나중에 값을 할당해도 자동으로 타입이 부여된다.

따라서 간단한 변수들은 타입을 생략해도 괜찮다.

---

# 타입을 미리 정하기 애매할 때

### union type

`|` 연산자를 사용한다.

```ts
let myName: string | number = 'Jeong';
let age: (string | number) = 100; // 괄호로 감싸도 된다.

myName = 123;
age = '100';
```

이렇게 하면 변수에 string 또는 number 타입만 들어올 수 있다. 할당하는 순간 string 또는 number로 변한다.

---

다음 코드에서는 에러가 발생한다.

```ts
let myName: string | number;

myName + 1;
```

myName이라는 변수가 `string`인지 `number`인지 정해지지 않았기 때문(union type 이라고 생각)

---

array, object 자료를 만들 때도 union type을 사용할 수 있다.

```ts
let num: (number | string)[] = [1, '2', 3];
let obj: { data: number | string } = { data: '123' };
```

---

### any type

아무 자료나 집어넣을 수 있는 타입이다.

```ts
let myName: any = 'Jeong';

myName = 123;
myName = [];
```

되도록 사용하지 않는 것이 좋다! (비상시에만 사용)

---

### unknown type

`any`와 같이 모든 타입을 집어 넣을 수 있다.

```ts
let myName: unknown = 'Jeong';

myName = 123;
myName = undefined;
```

어떤 타입이 들어올지 모르거나 다양한 타입을 집어넣어야 할 경우 `any` 보다 `unknown type`을 사용하는 것이 좋다.

any와 다른 특징은 자료를 집어 넣었을 때 타입이 그대로 `unknown`이라는 것이다.

---

또한 `any`와 다르게 `unknown` 타입은 다른 곳에 집어넣으려고 하면 에러가 발생한다.

```ts
let myName: unknown;

let a: string = myName; // error
```

---

다음 예시들에서도 에러가 발생한다.

```ts
let myName: unknown;

myName[0];
myName - 1;
myName.data;
```

---

따라서 `unknown` 타입인 변수를 조작하려면 내가 조작할 변수의 타입이 무엇인지 확실하게 체크하는 **narrowing** 또는 **assertion**을 해야 한다. 변수에 무엇이 들어있을지 애매한, 추측해야하는 상황에서 반드시 사용해야한다.

---

# 함수에 타입 지정하는 법

함수에 들어오는 자료(파라미터)와 나가는 자료(return 값)에 타입 지정이 가능하다.

```ts
function func(x: number): number {
  return x * 2;
}
```

---

파라미터에 타입을 지정하면 그 파라미터는 필수 파라미터가 된다.

파라미터가 없을 때도 함수를 사용하고 싶다면 `?` 를 사용한다.

```ts
function func(x?: number) {

}

func();
func(1);
```

### void 타입

'아무것도 없이 공허함'을 뜻하는 타입이다. return할 자료가 없는 함수의 타입으로 사용한다.

```ts
function func(x: number): void {
  return x * 2; // error
}
```

> 무언가를 return 하려고 할 때 에러가 난다. 함수가 return 하는 것을 방지하고 싶을 때 `void` 타입을 활용한다.

---

# Narrowing & Assertion

`string | number`와 같은 union 타입은 일반적인 조작이 불가능하다.

```ts
function func(x: number | string) {
  return x + 1; // error
}
```

이럴때는 타입을 하나로(narrowing) 바꾸거나, assert 해주어야 한다.

---

### Type Narrowing

Type Narrowing이란 if문 등을 사용해 타입을 하나로 정해주는 것을 말한다.

```ts
function func(x: number | string) {
  if (typeof x === 'number') {
    return x + 1;
  } else if (typeof x === 'string') {
    return x + 1;
  } else {
    return 0;
  }
}
```

if문과 typeof 키워드로 현재 파라미터의 타입을 검사해서 나누어주어야 에러가 나지 않는다.

> 꼭 typeof를 사용할 필요는 없고 타입을 하나로 확정지을 수 있는 코드라면 어떤 것도 narrowing 역할이 가능하다.

귀찮더라도 꼭 해주어야 하는데, 타입이 확실하지 않을 때 생기는 부작용을 막기위한 장치라고 생각하면 된다. 이렇게 코딩하는 것을 **'defensive 하게 코딩한다'**라고도 한다.

함수 안에서 if문을 쓸 때 마지막에 else가 없으면 에러가 난다.

---

### Type Assertion

narrowing 대신 assertion을 사용할 수 있다.

assertion은 '이 변수의 타입을 ~로 생각해 주세요'라는 것을 나타낸다.

```ts
function func(x: number | string) {
  return (x as number) + 1;
}
```

`변수명 as 타입`은 '이 변수는 이 타입이다'라는 뜻이며 실제로 그렇게 타입을 변경해준다.

> assertion는 해당 변수 값으로 무조건 해당 타입이 들어올 것을 반드시 알고 있어야 안전하게 사용할 수 있다.

> as 키워드는 union type 같은 복잡한 타입을 하나의 정확한 타입으로 줄이는 역할이다.(number 타입에 as string을 사용하면 에러가 난다.)

---

`as number`라고 하더라도 변수가 number 타입으로 바뀌는 것은 아니다. (실제로 타입을 바꿔주는 것은 아니다.)

```ts
function func(x: number | string) {
  return (x as number) + 1;
}

console.log(func('123')); // 1231
```

> 따라서 정확하게 코드를 짜려면 assertion 대신 narrowing을 쓰는 것이 좋다.

as 키워드는 타입을 개발자 마음대로 주장하는 역할이기 때문에 엄격한 타입 체크 기능을 잠시 사용하지 않는 것과 동일하다.

> 따라서 왜 타입 에러가 발생하는지 정말 모르겠는 상황에서 임시로 사용하거나, 내가 어떤 타입이 들어올지 정말 확실하게 알고 있는데 컴파일 에러가 방해할 때만 사용한다.

---

위의 경우 말고 assertion을 유용하게 사용하는 경우가 있다.

타입을 강제로 부여하는 함수를 하나 만들어 쓰고 싶을 때 함수에 데이터를 넣으면 as 타입명을 붙여서 return 하는 함수를 만들어 사용한다.

```ts
type Person = {
  name: string;
};

function trans<T>(data: string): T {
  return JSON.parse(data) as T;
}
```