---
layout: post
title: '[TypeScript] 사용하기'
categories: TypeScript
author: taeyeong
date: 2022-02-09T19:37:28+0900
---
* content
{:toc}


---

앞에서 배운것처럼 모든 변수에 타입을 지정할 필요는 없다. 변수 생성시 타입스크립트가 자동으로 타입을 부여해준다.

```ts
let myName = 'taeyeong';
let age = 28;
```

이렇게 하면 myName 변수에는 string, age 변수에는 number 타입이 부여된다.

array, object를 만들 때도 자동으로 된다.

```ts
let myName;

myName = 'taeyeong';
```

변수만 만들고 나중에 값을 할당해도 자동으로 타입이 부여된다.

따라서 간단한 변수들은 타입을 생략해도 괜찮다.

---

# 타입을 미리 정하기 애매할 때

### union type

`|` 연산자를 사용한다.

```ts
let myName: string | number = 'Jeong';
let age: (string | number) = 100; // 괄호로 감싸도 된다.

myName = 123;
age = '100';
```

이렇게 하면 변수에 string 또는 number 타입만 들어올 수 있다. 할당하는 순간 string 또는 number로 변한다.

---

다음 코드에서는 에러가 발생한다.

```ts
let myName: string | number;

myName + 1;
```

myName이라는 변수가 `string`인지 `number`인지 정해지지 않았기 때문(union type 이라고 생각)

---

array, object 자료를 만들 때도 union type을 사용할 수 있다.

```ts
let num: (number | string)[] = [1, '2', 3];
let obj: { data: number | string } = { data: '123' };
```

---

### any type

아무 자료나 집어넣을 수 있는 타입이다.

```ts
let myName: any = 'Jeong';

myName = 123;
myName = [];
```

되도록 사용하지 않는 것이 좋다! (비상시에만 사용)

---

### unknown type

`any`와 같이 모든 타입을 집어 넣을 수 있다.

```ts
let myName: unknown = 'Jeong';

myName = 123;
myName = undefined;
```

어떤 타입이 들어올지 모르거나 다양한 타입을 집어넣어야 할 경우 `any` 보다 `unknown type`을 사용하는 것이 좋다.

any와 다른 특징은 자료를 집어 넣었을 때 타입이 그대로 `unknown`이라는 것이다.

---

또한 `any`와 다르게 `unknown` 타입은 다른 곳에 집어넣으려고 하면 에러가 발생한다.

```ts
let myName: unknown;

let a: string = myName; // error
```

---

다음 예시들에서도 에러가 발생한다.

```ts
let myName: unknown;

myName[0];
myName - 1;
myName.data;
```

---

따라서 `unknown` 타입인 변수를 조작하려면 내가 조작할 변수의 타입이 무엇인지 확실하게 체크하는 **narrowing** 또는 **assertion**을 해야 한다. 변수에 무엇이 들어있을지 애매한, 추측해야하는 상황에서 반드시 사용해야한다.

---

# 함수에 타입 지정하는 법

함수에 들어오는 자료(파라미터)와 나가는 자료(return 값)에 타입 지정이 가능하다.

```ts
function func(x: number): number {
  return x * 2;
}
```

---

파라미터에 타입을 지정하면 그 파라미터는 필수 파라미터가 된다.

파라미터가 없을 때도 함수를 사용하고 싶다면 `?` 를 사용한다.

```ts
function func(x?: number) {

}

func();
func(1);
```

### void 타입

'아무것도 없이 공허함'을 뜻하는 타입이다. return할 자료가 없는 함수의 타입으로 사용한다.

```ts
function func(x: number): void {
  return x * 2; // error
}
```

> 무언가를 return 하려고 할 때 에러가 난다. 함수가 return 하는 것을 방지하고 싶을 때 `void` 타입을 활용한다.

---

# Narrowing & Assertion

`string | number`와 같은 union 타입은 일반적인 조작이 불가능하다.

```ts
function func(x: number | string) {
  return x + 1; // error
}
```

이럴때는 타입을 하나로(narrowing) 바꾸거나, assert 해주어야 한다.

---

### Type Narrowing

Type Narrowing이란 if문 등을 사용해 타입을 하나로 정해주는 것을 말한다.

```ts
function func(x: number | string) {
  if (typeof x === 'number') {
    return x + 1;
  } else if (typeof x === 'string') {
    return x + 1;
  } else {
    return 0;
  }
}
```

if문과 typeof 키워드로 현재 파라미터의 타입을 검사해서 나누어주어야 에러가 나지 않는다.

> 꼭 typeof를 사용할 필요는 없고 타입을 하나로 확정지을 수 있는 코드라면 어떤 것도 narrowing 역할이 가능하다.

귀찮더라도 꼭 해주어야 하는데, 타입이 확실하지 않을 때 생기는 부작용을 막기위한 장치라고 생각하면 된다. 이렇게 코딩하는 것을 **'defensive 하게 코딩한다'**라고도 한다.

함수 안에서 if문을 쓸 때 마지막에 else가 없으면 에러가 난다.

---

### Type Assertion

narrowing 대신 assertion을 사용할 수 있다.

assertion은 '이 변수의 타입을 ~로 생각해 주세요'라는 것을 나타낸다.

```ts
function func(x: number | string) {
  return (x as number) + 1;
}
```

`변수명 as 타입`은 '이 변수는 이 타입이다'라는 뜻이며 실제로 그렇게 타입을 변경해준다.

> assertion는 해당 변수 값으로 무조건 해당 타입이 들어올 것을 반드시 알고 있어야 안전하게 사용할 수 있다.

> as 키워드는 union type 같은 복잡한 타입을 하나의 정확한 타입으로 줄이는 역할이다.(number 타입에 as string을 사용하면 에러가 난다.)

---

`as number`라고 하더라도 변수가 number 타입으로 바뀌는 것은 아니다. (실제로 타입을 바꿔주는 것은 아니다.)

```ts
function func(x: number | string) {
  return (x as number) + 1;
}

console.log(func('123')); // 1231
```

> 따라서 정확하게 코드를 짜려면 assertion 대신 narrowing을 쓰는 것이 좋다.

as 키워드는 타입을 개발자 마음대로 주장하는 역할이기 때문에 엄격한 타입 체크 기능을 잠시 사용하지 않는 것과 동일하다.

> 따라서 왜 타입 에러가 발생하는지 정말 모르겠는 상황에서 임시로 사용하거나, 내가 어떤 타입이 들어올지 정말 확실하게 알고 있는데 컴파일 에러가 방해할 때만 사용한다.

---

위의 경우 말고 assertion을 유용하게 사용하는 경우가 있다.

타입을 강제로 부여하는 함수를 하나 만들어 쓰고 싶을 때 함수에 데이터를 넣으면 as 타입명을 붙여서 return 하는 함수를 만들어 사용한다.

```ts
type Person = {
  name: string;
};

function trans<T>(data: string): T {
  return JSON.parse(data) as T;
}
```

---

# type alias

```ts
let myName: string | number | undefined;
```

타입스크립트로 코드들 짜다보면 이렇게 길게 타입을 나열해야 하는 경우가 있다.

길어서 보기 싫거나 재사용을 하고 싶다면 타입을 변수에 담아 사용할 수 있다.

```ts
type MyType = string | number | undefined;

let myName: MyType;
```

이렇게 타입을 변수처럼 만들어서 사용하는 것을 alias 문법이라고 한다. 관습적으로 파스칼 케이스를 사용한다.(변수와 구분하기 위해)

---

당연히 object 타입도 저장할 수 있다.

```ts
type MyType = {
  name: string,
  age: number
}

let myName: MyType = {
  name: 'Jeong',
  age: 28
}
```

---

# readonly

자바스크립트에서 const로 선언된 변수가 object 자료형일 경우에는 내부의 속성을 변경해도 에러가 발생하지 않는다.

```ts
const person = {
  name = 'Jeong',
};

person.name = 'Kim';
```

`readonly`는 object의 속성까지 바뀌지 않게 막을 수 있는 타입스크립트 문법이다.

```ts
type Person = {
  readonly name: string;
}

const info: Person = {
  name: 'Jeong',
}

info.name: 'Kim'; // error
```

한 번 부여된 후에 바뀌면 안되는 속성들에 `readonly`를 사용하면 된다.

---

# ?

object alias를 만드는데, age라는 속성은 꼭 필요하지만 name 속성은 선택사항이라면 name 속성 뒤에 `?`를 붙인다.

```ts
type Person = {
  name?: string;
  age: number;
}

const info = {
  age: 28,
}
```

---

# type 키워드 합치기

두 개의 타입을 `|`(OR) 연산자를 이용해서 하나의 union 타입으로 만들 수도 있다.

```ts
type Name = string;
type Age = number;
type NewType = Name | Age;
```

`&`(AND) 연산자를 사용하면 object 안의 속성을 합칠수 있다. 이렇게 속성을 합치는 것을 extend 한다고 부른다.

```ts
type Name = { name: string };
type Age = { age: number};
type Person = Name & Age; // = { name: string; age: number; }

const info: Person = {
  name: 'Jeong',
  age: 28,
}
```

아래와 같이 사용할 수도 있다.

```ts
type Name = { name: string };
type Person = Name & { age: number };
```

---

중복된 속성이 다른 타입일 때 `&`를 이용해서 합치면 `never`라는 타입이 생성되는 것 같다.

```ts
type A = {
  age: string;
};

type B = {
  age: number;
};

type C = A & B; // never type?
```

---

type 키워드는 재정의가 불가능하다.

```ts
type MyType = string;
type MyType = number; // error
```

type 대신 interface라는 키워드를 사용하면 재정의가 가능하지만 재정의 불가능 한 것이 더 안전하다.

---

# Literal Types

string, number 외에 특정 문자열이나 숫자도 타입이 될 수 있다.

```ts
let myName: 'Taeyeong';
let age: 28;
```

myName 변수에는 'Taeyeong'이라는 문자열, age 변수에는 28이라는 숫자 외에 어떤 값도 할당할 수 없다.

이렇게 특정 문자열이나 숫자만 가질 수 있게 제한을 두는 타입을 **literal type**이라고 부른다.

---

literal 타입에 `|`를 붙일 수도 있다.

```ts
let myName: 'Taeyeong' | 'Jeong';
```

myName 변수에는 'Taeyeong'이라는 문자열 또는 'Jeong'이라는 문자열만 할당할 수 있다.

---

함수에도 똑같이 사용 가능하다.

```ts
function func(a: 'hi'): 'hello' {
  return 'hello';
}
```

func이라는 함수는 오직 'hi'라는 문자열만 파라미터로 넣을 수 있고, 'hello'라는 문자열만 반환할 수 있다.

---

# as const

```ts
const a = {
  name: 'Jeong',
};

function func(b: 'Jeong') {
  return true;
}

func(a.name); // error
```

`func(a.name)`에서 오류가 발생하는 이유는 a.name은 'Jeong'이라는 string 타입이고, b에는 'Jeong'이라는 literal type이 들어와야 하기 때문이다.

이런 경우 `as const`를 사용하면 된다.

```ts
const a = {
  name: 'Jeong',
} as const;

function func(b: 'Jeong') {
  return true;
}

func(a.name); // error
```

`as const`는 두 가지 기능을 한다.

1. object 속성의 타입을 value로 바꾼다. 여기서는 a.name의 타입이 value인 'Jeong'으로 바뀐다.
2. object 안에 있는 모든 속성을 readonly로 바꾼다.

---

# function type

함수 타입도 type alias로 저장해서 사용할 수 있다.

숫자 두 개를 파라미터로 입력해야하고, 숫자를 return 하는 함수를 type로 만든다면

```ts
type Func = (x: number, y: number) => number;
```

이렇게 만들면 된다.

이렇게 만든 function type을 함수에 적용할 때 `function a: Func() {}`이렇게 사용할 수는 없다.

```ts
type Func = (x: number, y: number) => number;

let a: Func = function(x, y) {
  return x + y;
}
```

이렇게 함수를 변수에 할당하는 방법을 사용하면 된다.

---
